
%code{
  #include <string>
  #include <vector>
  #include <stdint.h>
  #include <typeinfo>
  // Debugging only
  #include <sstream>
  #include "tokens.hpp"
  #include "scanner.hpp"
  #include "parser.hpp"
  #include "symbol.hpp"
  #include "data_object.hpp"

  #undef yylex
  #define yylex scanner.yylex

  #define str_arr_t std::vector<char*>
  #define sym_arr_t std::list<Symbol*>
  //#define half_expr_t std::pair<int, DataObject*>

  #undef yyparse
  //#define half_expr_is_valid(half_expr) \
  //  ((half_expr).second != 0)
  int block_num=1;

  void yyerror (LittleParser& parser, LittleScanner& scanner, const char* err);
}

%parse-param {LittleParser& parser}
%parse-param {LittleScanner& scanner}


%union{
  double float_val;
  int int_val;
  char* str_val;
  void* str_arr;

  // std::vector<Symbol*>*
  void* sym_arr;

  // Symbol*
  void* sym;

  // Operation enum
  int op;

  // DataObject*
  void* data_obj;

  // std::pair<op, DataObject*>*
  void* half_expr;


}

%token    <int_val> PROGRAM
%token    <int_val> END
%token    <str_val> IDENTIFIER
%token    <str_val> STRING
%token    <str_val> STRINGLITERAL
%token    <str_val> FLOAT
%token    <str_val> INT
%token    <str_val> VOID
%token    <str_val> FUNCTION
%token    <str_val> BEGINT
%token    <str_val> READ
%token    <str_val> WRITE
%token    <str_val> RETURN
%token    <str_val> INTLITERAL
%token    <str_val> FLOATLITERAL
%token    <str_val> PLUS
%token    <str_val> MINUS
%token    <str_val> MULTIPLY
%token    <str_val> DIVIDE
%token    <str_val> IF
%token    <str_val> ENDIF
%token    <str_val> ELSIF
%token    <str_val> TRUE
%token    <str_val> FALSE
%token    <str_val> LESSTHAN
%token    <str_val> GREATERTHAN
%token    <str_val> EQUAL
%token    <str_val> NOTEQUAL
%token    <str_val> LESSTHANEQUAL
%token    <str_val> GREATERTHANEQUAL
%token    <str_val> DO
%token    <str_val> WHILE
%token    <str_val> CONTINUE
%token    <str_val> BREAK
%token    <str_val> COMMENT
%token    <str_val> COLONEQUAL
%token    <str_val> PARANTHLEFT
%token    <str_val> PARANTHRIGHT
%token    <str_val> SEMICOLON
%token    <str_val> COMMA

%type     <str_val> id
%type     <str_val> str
%type     <str_arr> id_list
%type     <str_arr> id_tail

%type     <sym_arr> param_decl_list
%type	  <sym_arr> param_decl_tail
%type	  <sym>	    param_decl
%type     <int_val> var_type

%type	  <op>	    mulop
%type     <op>	    addop

%type	  <data_obj>	    primary
%type	  <data_obj>	    expr
%type	  <data_obj>	    factor
%type	  <data_obj>	    postfix_expr
%type	  <data_obj>	    call_expr

%type	  <half_expr> factor_prefix
%type	  <half_expr> expr_prefix

%%
  /* Program */
  program
    : program_head id BEGINT pgm_body END {
      parser.table_factory.pop_table();
      free($2);
    }
    ;
  program_head
    : PROGRAM {
      parser.table_factory.push_table("GLOBAL");
      }
    ;
  id
    : IDENTIFIER 
    ;
  pgm_body
    : decl func_declarations 
    ;
  decl
    : string_decl decl 
    | var_decl decl 
    | 
    ;

  /* Global String Declaration */
  string_decl
    : STRING id COLONEQUAL str SEMICOLON {
      Symbol::T value;
      value.s = $4;
      if (! parser.table_factory.insert_symbol(Symbol($2, Symbol::STRING, value))){
	free($2);
	yyerror(parser,scanner, "Redeclaration Error");
	YYABORT;
      }
      else
	free($2);
    };
  str
    : STRINGLITERAL {$$ = $1;}
    ;

  /* Variable Declaration */
  var_decl
    : var_type id_list SEMICOLON {
      str_arr_t* pArr = static_cast<str_arr_t*>($2);
      str_arr_t::iterator it;
      for (it = pArr->begin(); it != pArr->end(); it++){
	Symbol::T fun;
	Symbol sym (*it, static_cast<Symbol::Types>($1), fun);
	if(!parser.table_factory.insert_symbol(sym)){
	  yyerror(parser,scanner, "Redeclaration Error");
	  YYABORT;
	}
      }
    }
    ;
  var_type
    : FLOAT {$$ = Symbol::FLOAT;}
    | INT {$$ = Symbol::INT;}
    ;
  any_type
    : var_type 
    | VOID 
    ;
  id_list
    : id id_tail {
      str_arr_t* pArr;
      $$ = $2;
      pArr = static_cast<str_arr_t*>($2);
      pArr->insert(pArr->begin(), $1);
    }
    ;
  id_tail
    : COMMA id id_tail {
      str_arr_t* pArr;
      $$ = $3;
      pArr = static_cast<str_arr_t*>($3);
      pArr->insert(pArr->begin(), $2);
    }
    | {
      str_arr_t* str_arr = new str_arr_t();
      parser.register_str_arr(str_arr);
      $$ = static_cast<void*>(str_arr);
    }
    ;

  /* Function Paramater List */
  param_decl_list
    : param_decl param_decl_tail {
      sym_arr_t* pArr = static_cast<sym_arr_t*>($2);
      Symbol* pSym = static_cast<Symbol*>($1);
      pArr->push_front(pSym);
      $$ = pArr;
      sym_arr_t::iterator it;
      for (it = pArr->begin(); it != pArr->end(); it++){
	pSym = *it;
	/*
	if (pSym->Type == Symbol::INT){
	  std::cout <<
	  "insert_symbol("<<pSym->Name<<", INT, NULL)" <<
	  std::endl;
	}
	else {
	  std::cout <<
	  "insert_symbol("<<pSym->Name<<", FLOAT, NULL)";
	}
	*/
	if (!parser.table_factory.insert_symbol(*pSym)){
	  yyerror(parser,scanner, "Redeclaration Error");
	  YYABORT;
	}
      }
    }
    | {$$ = 0;}
    ;
  param_decl
    : var_type id{
      Symbol::T value;
      $$ = static_cast<void*>( 
	new Symbol($2, static_cast<Symbol::Types>($1), value)
	);
      free($2);
    }
    ;
  param_decl_tail
    : COMMA param_decl param_decl_tail {
      sym_arr_t* pArr = static_cast<sym_arr_t*>($3);
      Symbol* pSym = static_cast<Symbol*>($2);
      pArr->push_front(pSym);
      $$ = $3;
    }
    | {
	sym_arr_t* sym_arr = new sym_arr_t();
	$$ = static_cast<void*>(sym_arr);
	parser.register_sym_arr(sym_arr);
      }
    ;

  /* Function Declarations */
  func_declarations
    : func_decl func_declarations 
    |
    ;
  func_head
    : FUNCTION any_type id {
      parser.table_factory.push_table($3);
      free($3);
    }
    ;
  func_decl
    : func_head PARANTHLEFT param_decl_list PARANTHRIGHT BEGINT func_body END {
      parser.table_factory.pop_table();
    }
    ;
  func_body
    : decl stmt_list 
    ;

  /* Statement List */
  stmt_list
    : stmt stmt_list 
    | 
    ;
  stmt
    : base_stmt 
    | if_stmt 
    | do_while_stmt 
    ;
  base_stmt
    : assign_stmt 
    | read_stmt 
    | write_stmt 
    | return_stmt 
    ;

  /* Basic Statements */
  assign_stmt
    : assign_expr SEMICOLON 
    ;
  assign_expr
    : id COLONEQUAL expr {
      IRI* iri;
      DataObject* dest = new DataObject(*parser.table_factory.get_symbol($1));
      DataObject* src = static_cast<DataObject*>($3);
      if (dest->data_type == DataObject::FLOAT)
	iri = IRI::create(IRI::STOREF, src->get_operand(), dest->get_operand());
      else
	iri = IRI::create(IRI::STOREI, src->get_operand(), dest->get_operand());
      parser.iri_list_push_back(iri);

      delete dest;
      delete src;
      free($1);
    } 
    ;
  read_stmt
    : READ PARANTHLEFT id_list PARANTHRIGHT SEMICOLON {
      // For each name in the id_list, generate a read statement
      std::stringstream ss;
      Symbol* symbol;
      IRI* iri;
      str_arr_t* str_arr = static_cast<str_arr_t*>($3);
      str_arr_t::iterator it;
      for (it = str_arr->begin(); it != str_arr->end(); it++) {
	symbol = parser.table_factory.get_symbol(*it);
	if (!symbol)
	  throw "Symbol not found!";
	DataObject data_object = DataObject(*symbol);
	iri = IRI::create(
	  data_object.data_type == DataObject::FLOAT ? IRI::READF : IRI::READI,
	  data_object.get_operand()
	);
	{
	  iri->PrintIRI(&ss);
	  // std::cerr << ss.rdbuf();
	  parser.iri_list_push_back(iri);
	}
      }
    }
    ;
  write_stmt
    : WRITE PARANTHLEFT id_list PARANTHRIGHT SEMICOLON {
      // For each name in the id_list, generate a write statement
      std::stringstream ss;
      Symbol* symbol;
      IRI* iri;
      str_arr_t* str_arr = static_cast<str_arr_t*>($3);
      str_arr_t::iterator it;
      for (it = str_arr->begin(); it != str_arr->end(); it++) {
	symbol = parser.table_factory.get_symbol(*it);
	if (!symbol)
	  throw "Symbol not found!";
	DataObject data_object = DataObject(*symbol);
	iri = IRI::create(
	  data_object.data_type == DataObject::FLOAT ? IRI::WRITEF : IRI::WRITEI,
	  data_object.get_operand()
	);
	{
	  iri->PrintIRI(&ss);
	  // std::cerr << ss.rdbuf();
	  parser.iri_list_push_back(iri);
	}
      }
    }
    ;
  return_stmt
    : RETURN expr SEMICOLON 
    ;

  /* Expressions */
  expr
    : expr_prefix factor {
      std::stringstream ss;
      half_expr_t* half_expr = static_cast<half_expr_t*>($1);
      IRI* iri;
      DataObject *result, *rhs;
      rhs = static_cast<DataObject*>($2);
      result = DataObject::evaluate_expression(half_expr, &iri, rhs);
      {
	if (iri){
	  iri->PrintIRI(&ss);
	  // std::cerr << ss.rdbuf();
	  parser.iri_list_push_back(iri);
	}
      }
      $$ = result;
      }
    ;
  expr_prefix
    : expr_prefix factor addop {
      std::stringstream ss;
      half_expr_t* half_expr = static_cast<half_expr_t*>($1);
      half_expr_t* new_half_expr;
      IRI* iri;
      DataObject *result, *rhs;
      rhs = static_cast<DataObject*>($2);
      result = DataObject::evaluate_expression(half_expr, &iri, rhs);
      {
	if (iri){
	  iri->PrintIRI(&ss);
	  // std::cerr << ss.rdbuf();
	  parser.iri_list_push_back(iri);
	}
      }
      new_half_expr = new half_expr_t($3, result);
      $$ = static_cast<void*>(new_half_expr);
    }
    | {
	$$ = static_cast<void*>(new half_expr_t(0,(DataObject*)0));
      }
    ;
  factor
    : factor_prefix postfix_expr {
      std::stringstream ss;
      half_expr_t* half_expr = static_cast<half_expr_t*>($1);
      IRI* iri;
      DataObject *result, *rhs;
      rhs = static_cast<DataObject*>($2);
      result = DataObject::evaluate_expression(half_expr, &iri, rhs);
      {
	if (iri){
	  iri->PrintIRI(&ss);
	  // std::cerr << ss.rdbuf();
	  parser.iri_list_push_back(iri);
	}
      }
      $$ = result;
    }
    ;
  factor_prefix
    : factor_prefix postfix_expr mulop {
      std::stringstream ss;
      half_expr_t* half_expr = static_cast<half_expr_t*>($1);
      half_expr_t* new_half_expr;
      IRI* iri;
      DataObject *result, *rhs;
      rhs = static_cast<DataObject*>($2);
      result = DataObject::evaluate_expression(half_expr, &iri, rhs);
      {
	if (iri){
	  iri->PrintIRI(&ss);
	  // std::cerr << ss.rdbuf();
	  parser.iri_list_push_back(iri);
	}
      }
      new_half_expr = new half_expr_t($3, result);
      $$ = static_cast<void*>(new_half_expr);
    }
    | {
	$$ = static_cast<void*>(new half_expr_t(0,(DataObject*)0));
      }
    ;
  postfix_expr
    : primary 
    | call_expr
    ;
  call_expr
    : id PARANTHLEFT expr_list PARANTHRIGHT {free($1); $$=0;} 
    ;
  expr_list
    : expr expr_list_tail 
    | 
    ;
  expr_list_tail
    : COMMA expr expr_list_tail 
    | 
    ;
  primary
    : PARANTHLEFT expr PARANTHRIGHT {$$ = $2;} 
    | id {
	Symbol* sym = parser.table_factory.get_symbol($1);
	if (!sym)
	  /* problems */ ;
	$$ = static_cast<void*>(new DataObject(*sym));
	free($1);
      }
    | INTLITERAL {
	std::stringstream ss;
	Operand int_literal = Operand(Operand::INTLITERAL, $1);
	DataObject* data_object = new DataObject(DataObject::INT); // Store this in a temp register
	IRI* iri = IRI::create(IRI::STOREI, int_literal, data_object->get_operand());
	iri->PrintIRI(&ss);
	{
	  // std::cerr << ss.rdbuf();
	  parser.iri_list_push_back(iri);
	}
	$$ = static_cast<void*>(data_object);
      }
    | FLOATLITERAL {
	std::stringstream ss;
	Operand int_literal = Operand(Operand::FLOATLITERAL, $1);
	DataObject* data_object = new DataObject(DataObject::FLOAT); // Store this in a temp register
	IRI* iri = IRI::create(IRI::STOREF, int_literal, data_object->get_operand());
	{
	  iri->PrintIRI(&ss);
	  //std::cerr << ss.rdbuf();
	  parser.iri_list_push_back(iri);
	}
	$$ = static_cast<void*>(data_object);
      }

    ;
  addop
    : PLUS {$$ = ADD;}
    | MINUS {$$ = SUB;}
    ;
  mulop
  : MULTIPLY {$$ = MUL;}
  | DIVIDE {$$ = DIV;}
  ;

  /* Complex Statements and Condition */
  /*if_stmt: IF PARANTHLEFT cond PARANTHRIGHT decl stmt_list else_part ENDIF ;*/
  if_head
    : IF {
      std::string name ("BLOCK ");
      std::string num = std::to_string(static_cast<long long>(block_num++));
      name += num;
      parser.table_factory.push_table(name);
      //std::cout << "Symbol Table BLOCK " << block_num++ << std::endl;
    }
    ;
  if_part
    : if_head PARANTHLEFT cond PARANTHRIGHT decl stmt_list {
      parser.table_factory.pop_table();
      //std::cout << "Pop Symbol Table"<< std::endl;
      }
    ;
  else_head
    : ELSIF {
      std::string name ("BLOCK ");
      std::string num = std::to_string(static_cast<long long>(block_num++));
      name += num;
      parser.table_factory.push_table(name);
      //std::cout << "Symbol Table BLOCK " << block_num++ << std::endl;
    }
    ;
  else_part
    : else_head PARANTHLEFT cond PARANTHRIGHT decl stmt_list {
      parser.table_factory.pop_table();
      //std::cout << "Pop Symbol Table"<< std::endl;
    } 
    ;
  else_part_recursive
    : else_part else_part_recursive
    |
    ;
  if_stmt
    : if_part else_part_recursive ENDIF
    ;
  cond: expr compop expr | TRUE | FALSE ;
  compop: LESSTHAN | GREATERTHAN | EQUAL | NOTEQUAL | LESSTHANEQUAL | GREATERTHANEQUAL ;

  do_head
    : DO {
      std::string name ("BLOCK ");
      std::string num = std::to_string(static_cast<long long>(block_num++));
      name += num;
      parser.table_factory.push_table(name);
      //std::cout << "Symbol Table BLOCK " << block_num++ << std::endl;
    }
    ;
  do_while_stmt
    : do_head decl stmt_list WHILE PARANTHLEFT cond PARANTHRIGHT SEMICOLON {
      parser.table_factory.pop_table();
      //std::cout << "Pop Symbol Table" << std::endl;
    }
    ;

%%

void yyerror(LittleParser& parser, LittleScanner& scanner, const char* error){
    return parser.error(error);
  }

