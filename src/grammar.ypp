
%code{
  #include <string>
  #include <vector>
  #include <stdint.h>
  #include <typeinfo>
  #include "tokens.hpp"
  #include "scanner.hpp"
  #include "parser.hpp"
  #include "symbol.hpp"

  #undef yylex
  #define yylex scanner.yylex

  #define str_arr_t std::vector<char*>
  #define sym_arr_t std::list<Symbol*>

  #undef yyparse
  //#define yyparse LittleParser::yyparse
  //#undef yyerror
  //#define yyerror LittleParser::error

  //#undef YYPARSE_PARAM
  // delete me
  int block_num=1;

  void yyerror (LittleParser& parser, LittleScanner& scanner, const char* err);
}

%parse-param {LittleParser& parser}
%parse-param {LittleScanner& scanner}


%union{
  double float_val;
  int int_val;
  char* str_val;
  void* str_arr;
  void* sym_arr;
  void* sym;

}

%token    <int_val> PROGRAM
%token    <int_val> END
%token    <str_val> IDENTIFIER
%token    <str_val> STRING
%token    <str_val> STRINGLITERAL
%token    <str_val> FLOAT
%token    <str_val> INT
%token    <str_val> VOID
%token    <str_val> FUNCTION
%token    <str_val> BEGINT
%token    <str_val> READ
%token    <str_val> WRITE
%token    <str_val> RETURN
%token    <int_val> INTLITERAL
%token    <str_val> FLOATLITERAL
%token    <str_val> PLUS
%token    <str_val> MINUS
%token    <str_val> MULTIPLY
%token    <str_val> DIVIDE
%token    <str_val> IF
%token    <str_val> ENDIF
%token    <str_val> ELSIF
%token    <str_val> TRUE
%token    <str_val> FALSE
%token    <str_val> LESSTHAN
%token    <str_val> GREATERTHAN
%token    <str_val> EQUAL
%token    <str_val> NOTEQUAL
%token    <str_val> LESSTHANEQUAL
%token    <str_val> GREATERTHANEQUAL
%token    <str_val> DO
%token    <str_val> WHILE
%token    <str_val> CONTINUE
%token    <str_val> BREAK
%token    <str_val> COMMENT
%token    <str_val> COLONEQUAL
%token    <str_val> PARANTHLEFT
%token    <str_val> PARANTHRIGHT
%token    <str_val> SEMICOLON
%token    <str_val> COMMA

%type     <str_val> id
%type     <str_val> str
%type     <str_arr> id_list
%type     <str_arr> id_tail

%type     <sym_arr> param_decl_list
%type	  <sym_arr> param_decl_tail
%type	  <sym>	    param_decl
%type     <int_val> var_type

%%
  /* Program */
  program
    : program_head id BEGINT pgm_body END {
      parser.table_factory.pop_table();
    }
    ;
  program_head
    : PROGRAM {
      parser.table_factory.push_table("GLOBAL");
      }
    ;
  id
    : IDENTIFIER 
    ;
  pgm_body
    : decl func_declarations 
    ;
  decl
    : string_decl decl 
    | var_decl decl 
    | 
    ;

  /* Global String Declaration */
  string_decl
    : STRING id COLONEQUAL str SEMICOLON {
      Symbol::T value;
      value.s = $4;
      if (! parser.table_factory.insert_symbol(Symbol($2, Symbol::STRING, value))){
	free($2);
	yyerror(parser,scanner, "Redeclaration Error");
	YYABORT;
      }
      else
	free($2);
    };
  str
    : STRINGLITERAL {$$ = $1;}
    ;

  /* Variable Declaration */
  var_decl
    : var_type id_list SEMICOLON {
      str_arr_t* pArr = static_cast<str_arr_t*>($2);
      str_arr_t::iterator it;
      for (it = pArr->begin(); it != pArr->end(); it++){
	Symbol::T fun;
	Symbol sym (*it, static_cast<Symbol::Types>($1), fun);
	if(!parser.table_factory.insert_symbol(sym)){
	  yyerror(parser,scanner, "Redeclaration Error");
	  YYABORT;
	}
      }
    }
    ;
  var_type
    : FLOAT {$$ = Symbol::FLOAT;}
    | INT {$$ = Symbol::INT;}
    ;
  any_type
    : var_type 
    | VOID 
    ;
  id_list
    : id id_tail {
      str_arr_t* pArr;
      $$ = $2;
      pArr = static_cast<str_arr_t*>($2);
      pArr->insert(pArr->begin(), $1);
    }
    ;
  id_tail
    : COMMA id id_tail {
      str_arr_t* pArr;
      $$ = $3;
      pArr = static_cast<str_arr_t*>($3);
      pArr->insert(pArr->begin(), $2);
    }
    | {
      str_arr_t* str_arr = new str_arr_t();
      parser.register_str_arr(str_arr);
      $$ = static_cast<void*>(str_arr);
    }
    ;

  /* Function Paramater List */
  param_decl_list
    : param_decl param_decl_tail {
      sym_arr_t* pArr = static_cast<sym_arr_t*>($2);
      Symbol* pSym = static_cast<Symbol*>($1);
      pArr->push_front(pSym);
      $$ = pArr;
      sym_arr_t::iterator it;
      for (it = pArr->begin(); it != pArr->end(); it++){
	pSym = *it;
	/*
	if (pSym->Type == Symbol::INT){
	  std::cout <<
	  "insert_symbol("<<pSym->Name<<", INT, NULL)" <<
	  std::endl;
	}
	else {
	  std::cout <<
	  "insert_symbol("<<pSym->Name<<", FLOAT, NULL)";
	}
	*/
	if (!parser.table_factory.insert_symbol(*pSym)){
	  yyerror(parser,scanner, "Redeclaration Error");
	  YYABORT;
	}
      }
    }
    | {$$ = 0;}
    ;
  param_decl
    : var_type id{
      Symbol::T value;
      $$ = static_cast<void*>( 
	new Symbol($2, static_cast<Symbol::Types>($1), value)
	);
    }
    ;
  param_decl_tail
    : COMMA param_decl param_decl_tail {
      sym_arr_t* pArr = static_cast<sym_arr_t*>($3);
      Symbol* pSym = static_cast<Symbol*>($2);
      pArr->push_front(pSym);
      $$ = $3;
    }
    | {
	sym_arr_t* sym_arr = new sym_arr_t();
	$$ = static_cast<void*>(sym_arr);
	parser.register_sym_arr(sym_arr);
      }
    ;

  /* Function Declarations */
  func_declarations
    : func_decl func_declarations 
    |
    ;
  func_head
    : FUNCTION any_type id {
      parser.table_factory.push_table($3);
      //std::cout << "Symbol Table " << $3 << std::endl;
    }
    ;
  func_decl
    : func_head PARANTHLEFT param_decl_list PARANTHRIGHT BEGINT func_body END {
      //std::cout << "Pop Symbol Table" << std::endl;
      parser.table_factory.pop_table();
    }
    ;
  func_body
    : decl stmt_list 
    ;

  /* Statement List */
  stmt_list
    : stmt stmt_list 
    | 
    ;
  stmt
    : base_stmt 
    | if_stmt 
    | do_while_stmt 
    ;
  base_stmt
    : assign_stmt 
    | read_stmt 
    | write_stmt 
    | return_stmt 
    ;

  /* Basic Statements */
  assign_stmt
    : assign_expr SEMICOLON 
    ;
  assign_expr
    : id COLONEQUAL expr 
    ;
  read_stmt
    : READ PARANTHLEFT id_list PARANTHRIGHT SEMICOLON 
    ;
  write_stmt
    : WRITE PARANTHLEFT id_list PARANTHRIGHT SEMICOLON 
    ;
  return_stmt
    : RETURN expr SEMICOLON 
    ;

  /* Expressions */
  expr
    : expr_prefix factor 
    ;
  expr_prefix
    : expr_prefix factor addop 
    | 
    ;
  factor
    : factor_prefix postfix_expr 
    ;
  factor_prefix
    : factor_prefix postfix_expr mulop 
    | 
    ;
  postfix_expr
    : primary 
    | call_expr 
    ;
  call_expr
    : id PARANTHLEFT expr_list PARANTHRIGHT 
    ;
  expr_list
    : expr expr_list_tail 
    | 
    ;
  expr_list_tail
    : COMMA expr expr_list_tail 
    | 
    ;
  primary
    : PARANTHLEFT expr PARANTHRIGHT 
    | id 
    | INTLITERAL 
    | FLOATLITERAL 
    ;
  addop
    : PLUS 
    | MINUS 
    ;
  mulop
  : MULTIPLY 
  | DIVIDE 
  ;

  /* Complex Statements and Condition */
  /*if_stmt: IF PARANTHLEFT cond PARANTHRIGHT decl stmt_list else_part ENDIF ;*/
  if_head
    : IF {
      std::string name ("BLOCK ");
      std::string num = std::to_string(static_cast<long long>(block_num++));
      name += num;
      parser.table_factory.push_table(name);
      //std::cout << "Symbol Table BLOCK " << block_num++ << std::endl;
    }
    ;
  if_part
    : if_head PARANTHLEFT cond PARANTHRIGHT decl stmt_list {
      parser.table_factory.pop_table();
      //std::cout << "Pop Symbol Table"<< std::endl;
      }
    ;
  else_head
    : ELSIF {
      std::string name ("BLOCK ");
      std::string num = std::to_string(static_cast<long long>(block_num++));
      name += num;
      parser.table_factory.push_table(name);
      //std::cout << "Symbol Table BLOCK " << block_num++ << std::endl;
    }
    ;
  else_part
    : else_head PARANTHLEFT cond PARANTHRIGHT decl stmt_list {
      parser.table_factory.pop_table();
      //std::cout << "Pop Symbol Table"<< std::endl;
    } 
    ;
  else_part_recursive
    : else_part else_part_recursive
    |
    ;
  if_stmt
    : if_part else_part_recursive ENDIF
    ;
  cond: expr compop expr | TRUE | FALSE ;
  compop: LESSTHAN | GREATERTHAN | EQUAL | NOTEQUAL | LESSTHANEQUAL | GREATERTHANEQUAL ;

  do_head
    : DO {
      std::string name ("BLOCK ");
      std::string num = std::to_string(static_cast<long long>(block_num++));
      name += num;
      parser.table_factory.push_table(name);
      //std::cout << "Symbol Table BLOCK " << block_num++ << std::endl;
    }
    ;
  do_while_stmt
    : do_head decl stmt_list WHILE PARANTHLEFT cond PARANTHRIGHT SEMICOLON {
      parser.table_factory.pop_table();
      //std::cout << "Pop Symbol Table" << std::endl;
    }
    ;

%%

void yyerror(LittleParser& parser, LittleScanner& scanner, const char* error){
    return parser.error(error);
  }

